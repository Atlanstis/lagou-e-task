# Part1-2 作业

( 请在当前文件直接作答 )

## 简答题

### 1. 请说出下列最终执行结果，并解释为什么?

```javascript
var a = [];
for(var i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i)
  }
}
a[6]()
```

10；

使用 var 声明的 i 会定义在全局变量中，在 for 循环执行完毕后，i 的值被赋值为10。调用 `a[6]()`时，访问的 i 是全局变量中的 i，因此返回 10。

　

### 2. 请说出此案列最终执行结果，并解释为什么?

```javascript
var tmp = 123;
if (true) {
  console.log(tmp);
  let tmp;
}
```

报错，并返回 Uncaught ReferenceError: Cannot access 'tmp' before initialization。

使用 let 声明的变量，会在当前作用域形成暂时性死区，凡是在声明之前就使用这些变量，就会报错。　

### 3. 结合ES6语法，用最简单的方式找出数组中的最小值

```javascript
var arr = [12, 34, 32, 89, 4]
```

Math.min(...arr)

### 4. 请详细说明var、let、const三种声明变量的方式之间的具体差别

1. var 声明的变量会挂载到顶级对象中，let 和 const 不会。
2. var 声明的变量存在变量提升，let 和 const 不会。
3. let 和 const 声明形成块级作用域，只能在块级作用域内访问。
4. 同一作用域下，let 和 const 不能声明同名变量，而 var 可以。
5. let 和 const 会形成暂时性死区，不能在声明前被使用。
6. const 在赋值后，不能被改变，而 let 可以。

### 5. 请说出下列代码最终输出结果，并解释为什么？

```javascript
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn()
```

20。

首先，匿名函数并不会改变 this 的指向。同时，this的指向在函数创建的时候是决定不了的，其指向调用其的对象。在此例中，fn() 由 obj 对象调用，因此 this 指向 obj，所以，this.a 等于 obj.a，等于 20。

### 6. 简述Symbol类型的用途

1. 用于创建独一无二的值，可做唯一 key。
2. 利用 Symbol 属性不能被枚举的特性声明类的私有属性。
3. 利用 Symbol.toStringTag，重置对象的 toString 方法，返回的值。
4. 通过 Symbol.iterator，让普通对象变成可迭代对象。

### 7. 说说什么是浅拷贝，什么是深拷贝？

浅拷贝，是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝，如果拷贝的属性是基本类型，拷贝的就是基本类型的值。如果拷贝的是引用类型，拷贝的是其内存地址，如果该属性发生变化，会影响到原有对象。

深拷贝是将一个对象从内存中完整的进行拷贝创建一个新的对象，并开辟新的内存空间存放这个新的对象，前后两个对象没有任何关系，修改新的对象，不会影响原对象。

### 8. 请简述TypeScript与JavaScript之间的关系？

　TypeScript 是 JavaScript 的超集，包含了 JavaScript 的所有元素，拓展了类型系统、ES新特性的支持。

### 9. 请谈谈你所认为的typescript优缺点

　优点：拓展了 JavaScript 的功能；在编译阶段就发现大部分错误，预防因人为书写问题导致的代码报错，增强项目的可维护性。

　缺点：更高的学习成本。

### 10. 描述引用计数的工作原理和优缺点

　当声明了一个变量，并将一个引用对象值赋值给该变量时，则这个值的引用计数就为 1。如果这个值又被辅助给另一个变量时，则引用计数就再加 1。相反，当一个变量不再指向这个引用对象值的时候，则引用计数则减 1。当这个引用对象值的引用计数为 0 时，说明这个值就不能再被访问到，则可以将这个值所占用的空间回收回来。所以，当浏览器开始进行垃圾回收时，就可以将引用计数为 0 的值所占用的空间进行回收。

优点：发现垃圾时立即回收；最大限度减少程序暂停。

缺点：无法回收循环引用的对象；时间开销大。

### 11. 描述标记整理算法的工作流程

​	标记整理算法主要分成标记和整理两个阶段。在标记阶段，从根上去访问所有的可达对象，对所有的可达对象进行标记。在整理阶段，首先，将所有已标记的对象，向一侧移动，然后，再清理掉未标记一侧的对象，回收内存。　

### 12.描述V8中新生代存储区垃圾回收的流程

　V8 将新生代储存区分成两个相同的半空间，分别为 From 空间 和 To 空间。垃圾回收时，首先会先检查 From 空间存活的对象，并将这些对象复制到 To 空间。之后，会直接释放 From 空间的全部对象。再之后，将 From 空间与 To 空间互换。

​	当满足以下两个条件之一时，会发生晋升现象，即将对象移动到老生代。

- 对象是否经历过一次 GC
- To 空间的内存占比是否已经超过 25%

### 13. 描述增量标记算法在何时使用及工作原理

　由于在标记整理阶段，会阻碍主线程的执行，如果存在大量需要存活内存，务必回造成卡顿。因此，将原本一次遍历内存的阶段，分批执行。先标记内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个内存。之后，再对未标记的对象进行清除。



　